
## build

* 用法


	Usage: docker build [OPTIONS] PATH | URL | -

	Build a new image from the source code at PATH

	 -f, --file=""            Name of the Dockerfile (Default is 'PATH/Dockerfile')
	 --force-rm=false         Always remove intermediate containers
	 --no-cache=false         Do not use cache when building the image
	 --pull=false             Always attempt to pull a newer version of the image
	 -q, --quiet=false        Suppress the verbose output generated by the containers
	 --rm=true                Remove intermediate containers after a successful build
	 -t, --tag=""             Repository name (and optionally a tag) for the image
	 -m, --memory=""          Memory limit for all build containers
	 --memory-swap=""         Total memory (memory + swap), `-1` to disable swap
	 -c, --cpu-shares         CPU Shares (relative weight)
	 --cpuset-mems=""         MEMs in which to allow execution, e.g. `0-3`, `0,1`
	 --cpuset-cpus=""         CPUs in which to allow execution, e.g. `0-3`, `0,1`
	 --cgroup-parent=""       Optional parent cgroup for the container
	 --ulimit=[]              Ulimit options



* 例子

使用该命令，将会从参数指定的路径中的 Dockerfile的文件执行构建镜像，文件的指向可以是一个本地文件PATH或者是一个URL。

例如：

	$ sudo docker build https://github.com/docker/rootfs.git#container:docker

或者用标准输入：

	$ sudo docker build - < Dockerfile

如果你采用以上两种方式构建镜像，-f 或者－file参数将失效。

默认情况下，docker build 指令将会在指定根目录下查找Dockerfile文件，如果指定-f/-file参数，将指定该构建目录文件，这样的好处是可以多次构建。需要注意的是，路径必须包含构建信息的文件。

在多数情况下，最好保证构建目录为空。然后添加所需要的软件包到该文件夹。为了提高构建效率，可以加入 .dockerignore 文件排除一些不需要的文件。


返回值

如果构建成功，将会返回0，当失败时，将会返回相应错误返回值：

	$ docker build -t fail .
	Sending build context to Docker daemon 2.048 kB
	Sending build context to Docker daemon
	Step 0 : FROM busybox
	 ---> 4986bf8c1536
	Step 1 : RUN exit 13
	 ---> Running in e26670ec7a0a
	INFO[0000] The command [/bin/sh -c exit 13] returned a non-zero code: 13
	$ echo $?
	1

一般例子：

	$ docker build .
	Uploading context 10240 bytes
	Step 1 : FROM busybox
	Pulling repository busybox
	 ---> e9aa60c60128MB/2.284 MB (100%) endpoint: https://cdn-registry-1.docker.io/v1/
	Step 2 : RUN ls -lh /
	 ---> Running in 9c9e81692ae9
	total 24
	drwxr-xr-x    2 root     root        4.0K Mar 12  2013 bin
	drwxr-xr-x    5 root     root        4.0K Oct 19 00:19 dev
	drwxr-xr-x    2 root     root        4.0K Oct 19 00:19 etc
	drwxr-xr-x    2 root     root        4.0K Nov 15 23:34 lib
	lrwxrwxrwx    1 root     root           3 Mar 12  2013 lib64 -> lib
	dr-xr-xr-x  116 root     root           0 Nov 15 23:34 proc
	lrwxrwxrwx    1 root     root           3 Mar 12  2013 sbin -> bin
	dr-xr-xr-x   13 root     root           0 Nov 15 23:34 sys
	drwxr-xr-x    2 root     root        4.0K Mar 12  2013 tmp
	drwxr-xr-x    2 root     root        4.0K Nov 15 23:34 usr
	 ---> b35f4035db3f
	Step 3 : CMD echo Hello world
	 ---> Running in 02071fceb21b
	 ---> f52f38b7823e
	Successfully built f52f38b7823e
	Removing intermediate container 9c9e81692ae9
	Removing intermediate container 02071fceb21b

上面例子中，指定路径是 .,这个路径告诉docker构建的目录为当前目录，里面包含构建文件的信息，以及所要添加的文件。如果想保留构建过程中的容器，可以使用--rm=false ，这样操作不会影响构建缓存。

下面这个例子使用了.dockerignore文件来排除.git文件的使用方法，将会影响上下文文件大小。

	$ docker build .
	Uploading context 18.829 MB
	Uploading context
	Step 0 : FROM busybox
	 ---> 769b9341d937
	Step 1 : CMD echo Hello world
	 ---> Using cache
	 ---> 99cc1ad10469
	Successfully built 99cc1ad10469
		$ echo ".git" > .dockerignore
	$ docker build .
	Uploading context  6.76 MB
	Uploading context
	Step 0 : FROM busybox
	 ---> 769b9341d937
	Step 1 : CMD echo Hello world
	 ---> Using cache
	 ---> 99cc1ad10469
	Successfully built 99cc1ad10469

使用-t参数指定name以及tag：

	$ docker build -t vieux/apache:2.0 .

从标准输入读取Dockerfile：

	$ docker build - < Dockerfile

使用压缩文件，目前支持的格式是bzip2, gzip and xz

	$ docker build - < context.tar.gz

从克隆的GitHub仓库作为上下文构建镜像，在仓库根目录下的Dockerfile文件将作为构建文件。

	$ docker build github.com/creack/docker-firefox

注意，若要加前缀必须是 git:// 或者 git@ 。

使用-f参数指定文件构建

	$ docker build -f Dockerfile.debug .

在.目录下从不同文件构建镜像：

	$ docker build -f dockerfiles/Dockerfile.debug -t myapp_debug .
	$ docker build -f dockerfiles/Dockerfile.prod  -t myapp_prod .

我们在观察下面例子：

	$ cd /home/me/myapp/some/dir/really/deep
	$ docker build -f /home/me/myapp/dockerfiles/debug /home/me/myapp
	$ docker build -f ../../../../dockerfiles/debug /home/me/myapp

这个例子执行的两次构建操作所做事情是一模一样的，都会寻找debug文件作为Dockerfile来构建镜像。






